<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Hasher.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Hasher.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** ****************************************************************************************************
 * File: _Hasher.js
 * Project: geohash
 * @author Nick Soggin &lt;iSkore@users.noreply.github.com> on 14-Dec-2018
 *******************************************************************************************************/
'use strict';

const
	geohash                    = require( 'ngeohash' ),
	{ pointInside }            = require( './utils/geoUtils' ),
	{
		polygon: turfPolygon,
		featureCollection: turfFeaturecollection
	}                          = require( '@turf/helpers' ),
	{ default: bbox }          = require( '@turf/bbox' ),
	{ default: turfIntersect } = require( '@turf/intersect' ),
	geojsonArea                = require( 'geojson-area' );

/*
 * Hasher
 *
 * Calculate geohashes of specified precision that cover the (Multi)Polygon provided
 * Note, duplicates may occur.
 */
class Hasher
{
	constructor( options = {} )
	{
		const defaults = {
			precision: options.integerMode ? 32 : 6,
			rowMode: false,
			integerMode: false,
			geojson: [],
			splitAt: 2000,
			hashMode: 'inside',
			threshold: 0,
			...options
		};
		
		for( const attrName in defaults ) {
			this[ attrName ] = options.hasOwnProperty( attrName ) &amp;&amp;
			( !!options[ attrName ] || options[ attrName ] === false ) ?
				options[ attrName ] :
				defaults[ attrName ];
		}
		
		this.hashes = [];
		
		this.isMulti = Array.isArray( this.geojson[ 0 ][ 0 ][ 0 ] );
		this.geojson = !this.isMulti ? [ this.geojson ] : this.geojson;
		this.geojson = this.geojson.map( turfPolygon );
		
		this.geohashEncode     = geohash.encode;
		this.geohashDecode     = geohash.decode;
		this.geohashDecodeBbox = geohash.decode_bbox;
		this.geohashNeighbor   = geohash.neighbor;
	}
	
	calculate()
	{
		while( this.geojson.length ) {
			const hashes = this.getNextRow() || [];
			this.hashes.push( ...hashes );
		}
		
		return this.hashes;
	}
	
	makeRow( currentGeojson )
	{
		if( !this.rowHash ) {
			this.rowHash = this.geohashEncode( this.bounding[ 2 ], this.bounding[ 1 ], this.precision );
		}
		
		let rowBox     = this.geohashDecodeBbox( this.rowHash, this.precision ),
			columnHash = this.rowHash,
			rowHashes  = [];
		
		const prepared = this.preparePoly( currentGeojson, rowBox );
		
		let
			columnCenter = this.geohashDecode( columnHash, this.precision ),
			westerly     = this.geohashNeighbor(
				this.geohashEncode(
					columnCenter.latitude,
					this.rowBounding[ 3 ],
					this.precision
				),
				[ 0, 1 ],
				this.precision
			);
		
		while( columnHash !== westerly ) {
			console.log( columnCenter );
			if( this.hashMode === 'inside' &amp;&amp; pointInside( columnCenter, prepared ) ) {
				rowHashes.push( columnHash );
			} else if( this.hashMode === 'intersect' || this.hashMode === 'extent' ) {
				rowHashes.push( columnHash );
			}
			
			columnHash   = this.geohashNeighbor( columnHash, [ 0, 1 ], this.precision );
			columnCenter = this.geohashDecode( columnHash, this.precision );
		}
		
		const southNeighbour = this.geohashNeighbor( this.rowHash, [ -1, 0 ], this.precision );
		
		// Check if the current rowHash was already the most southerly hash on the map.
		// Also check if we are at or past the bottom of the bounding box.
		if( southNeighbour === this.rowHash || rowBox[ 0 ] &lt;= this.bounding[ 0 ] ) {
			this.geojson.pop();
			this.rowHash     = null;
			this.bounding    = null;
			this.rowBounding = null;
		} else {
			this.rowHash = southNeighbour;
		}
		
		if( this.hashMode === 'inside' || this.hashMode === 'extent' || !rowHashes.length ) {
			return rowHashes;
		} else if( this.hashMode === 'intersect' ) {
			
			let baseArea = null;
			
			return rowHashes.filter(
				h => {
					let bb = this.geohashDecodeBbox( h, this.precision );
					bb     = turfPolygon( [ [
						[ bb[ 1 ], bb[ 2 ] ],
						[ bb[ 3 ], bb[ 2 ] ],
						[ bb[ 3 ], bb[ 0 ] ],
						[ bb[ 1 ], bb[ 0 ] ],
						[ bb[ 1 ], bb[ 2 ] ]
					] ] );
					
					if( !baseArea ) {
						baseArea = geojsonArea.geometry( bb.geometry );
					}
					
					const intersected    = turfIntersect( prepared, bb );
					let keepIntersection = !this.threshold;
					
					if(
						this.threshold &amp;&amp;
						intersected &amp;&amp;
						(
							intersected.geometry.type === 'Polygon' ||
							intersected.geometry.type === 'MultiPolygon'
						)
					) {
						const intersectedArea = geojsonArea.geometry( intersected.geometry );
						keepIntersection      = baseArea &amp;&amp; intersectedArea / baseArea >= this.threshold;
					}
					
					return keepIntersection;
				}
			);
		}
	}
	
	/**
	 * getNextRow()
	 * will get the next row of geohashes for the current length-1 polygon in the list.
	 * only uses the current row bounds for checking pointinpoly
	 * rowHash persists so that it is available on the next iteration while the poly is still the same
	 */
	getNextRow()
	{
		const
			currentGeojson = this.geojson[ this.geojson.length - 1 ];
		
		if( !this.bounding ) {
			const extent = bbox( turfFeaturecollection( [ currentGeojson ] ) );
			
			// extent = [minX, minY, maxX, maxY], remap to match geohash lib
			this.bounding    = [ extent[ 1 ], extent[ 0 ], extent[ 3 ], extent[ 2 ] ];
			this.rowBounding = this.bounding.slice( 0 );
			return this.makeRow( currentGeojson );
		} else {
			return this.makeRow( currentGeojson );
		}
	}
	
	preparePoly( currentGeojson, rowBox )
	{
		// Detect poly length
		if( this.hashMode !== 'extent' &amp;&amp; currentGeojson.geometry.coordinates[ 0 ].length >= this.splitAt ) {
			const rowBuffer = 0.0002;
			
			const
				clipper      = turfPolygon( [ [
					[ this.bounding[ 1 ] - rowBuffer, rowBox[ 2 ] + rowBuffer ], // nw
					[ this.bounding[ 3 ] + rowBuffer, rowBox[ 2 ] + rowBuffer ], // ne
					[ this.bounding[ 3 ] + rowBuffer, rowBox[ 0 ] - rowBuffer ], // se
					[ this.bounding[ 1 ] - rowBuffer, rowBox[ 0 ] - rowBuffer ], // sw
					[ this.bounding[ 1 ] - rowBuffer, rowBox[ 2 ] + rowBuffer ]  // nw
				] ] ),
				intersection = turfIntersect(
					turfFeaturecollection( [ clipper ] ),
					turfFeaturecollection( [ currentGeojson ] )
				);
			
			if( intersection &amp;&amp; intersection.features.length ) {
				// Calculate the row bounding and column hash based on the intersection
				const
					intersectionFeature = {
						type: 'Feature',
						geometry: intersection.features[ 0 ],
						properties: {}
					},
					extent              = bbox( turfFeaturecollection( [ intersectionFeature ] ) );
				
				// extent = [minX, minY, maxX, maxY], remap to match geohash lib
				
				this.rowBounding = [ extent[ 1 ], extent[ 0 ], extent[ 3 ], extent[ 2 ] ];
				
				const
					midY = this.rowBounding[ 0 ] + ( this.rowBounding[ 2 ] - this.rowBounding[ 0 ] ) / 2;
				
				this.rowHash = this.geohashEncode( midY, this.rowBounding[ 1 ], this.precision );
				return intersection.features[ 0 ];
			} else {
				return currentGeojson.geometry;
			}
		} else {
			return currentGeojson.geometry;
		}
	}
	
	/**
	 * inside
	 * @description
	 * utilizing point-in-poly but providing support for geojson polys and holes.
	 * @param {Object} pt - lng, lat point
	 * @param {geojson} poly - polygon to check against
	 * @returns {*} - if the point resides within the polygon
	 */
	static inside( pt, poly )
	{
		console.log( 'inside' );
		if( poly.type !== 'Polygon' &amp;&amp; poly.type !== 'MultiPolygon' ) {
			return false;
		}
		
		const shape = poly.type === 'Polygon' ? [ poly.coordinates ] : poly.coordinates;
		let inside  = 0;
		
		shape.forEach(
			_poly => _poly.forEach(
				ring => !pointInside( [ pt.longitude, pt.latitude ], ring ) || inside++
			)
		);
		
		return inside % 2;
	}
}


/**
 * intializes the Hasher, but processes the results before returning an array.
 */
module.exports = Hasher;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#absoluteMaximum">absoluteMaximum</a></li><li><a href="global.html#absoluteMinimum">absoluteMinimum</a></li><li><a href="global.html#absoluteValue">absoluteValue</a></li><li><a href="global.html#arrayFilteredForRegex">arrayFilteredForRegex</a></li><li><a href="global.html#ascendingSort">ascendingSort</a></li><li><a href="global.html#bytesToSize">bytesToSize</a></li><li><a href="global.html#clamp">clamp</a></li><li><a href="global.html#convertHighResolutionTime">convertHighResolutionTime</a></li><li><a href="global.html#convertHRTimeToReadable">convertHRTimeToReadable</a></li><li><a href="global.html#decode">decode</a></li><li><a href="global.html#deepValues">deepValues</a></li><li><a href="global.html#defineProperty">defineProperty</a></li><li><a href="global.html#degreesToRadians">degreesToRadians</a></li><li><a href="global.html#determinePrecision">determinePrecision</a></li><li><a href="global.html#doublePrecisionDelta">doublePrecisionDelta</a></li><li><a href="global.html#encode">encode</a></li><li><a href="global.html#escapeRegExp">escapeRegExp</a></li><li><a href="global.html#findMissingKeys">findMissingKeys</a></li><li><a href="global.html#flattenObject">flattenObject</a></li><li><a href="global.html#floatPrecisionDelta">floatPrecisionDelta</a></li><li><a href="global.html#generateRandomHex">generateRandomHex</a></li><li><a href="global.html#generateRandomNumber">generateRandomNumber</a></li><li><a href="global.html#generateRandomString">generateRandomString</a></li><li><a href="global.html#geohashesWithinBBox">geohashesWithinBBox</a></li><li><a href="global.html#geohashesWithinBBoxToGeoJSON">geohashesWithinBBoxToGeoJSON</a></li><li><a href="global.html#geohashToBBox">geohashToBBox</a></li><li><a href="global.html#getBBoxStartingPoint">getBBoxStartingPoint</a></li><li><a href="global.html#getRandomInt">getRandomInt</a></li><li><a href="global.html#getValueForRegexKey">getValueForRegexKey</a></li><li><a href="global.html#isEven">isEven</a></li><li><a href="global.html#isOdd">isOdd</a></li><li><a href="global.html#isSemanticVersion">isSemanticVersion</a></li><li><a href="global.html#isUUIDv4">isUUIDv4</a></li><li><a href="global.html#isValidLatitude">isValidLatitude</a></li><li><a href="global.html#isValidLongitude">isValidLongitude</a></li><li><a href="global.html#mean">mean</a></li><li><a href="global.html#minAndMax">minAndMax</a></li><li><a href="global.html#neighbor">neighbor</a></li><li><a href="global.html#neighbors">neighbors</a></li><li><a href="global.html#nonEnumerableProperty">nonEnumerableProperty</a></li><li><a href="global.html#objectFilteredForRegex">objectFilteredForRegex</a></li><li><a href="global.html#objectId">objectId</a></li><li><a href="global.html#objectToFlatMap">objectToFlatMap</a></li><li><a href="global.html#percentChange">percentChange</a></li><li><a href="global.html#percentDifference">percentDifference</a></li><li><a href="global.html#percentError">percentError</a></li><li><a href="global.html#performanceDifference">performanceDifference</a></li><li><a href="global.html#pointInside">pointInside</a></li><li><a href="global.html#positiveFloorAddition">positiveFloorAddition</a></li><li><a href="global.html#precisionDelta">precisionDelta</a></li><li><a href="global.html#radiansToDegrees">radiansToDegrees</a></li><li><a href="global.html#radixToNumber">radixToNumber</a></li><li><a href="global.html#recursivePromiseResolve">recursivePromiseResolve</a></li><li><a href="global.html#regexpFromString">regexpFromString</a></li><li><a href="global.html#removeItemsFromArray">removeItemsFromArray</a></li><li><a href="global.html#removeItemsFromObject">removeItemsFromObject</a></li><li><a href="global.html#replaceMatchesWithValue">replaceMatchesWithValue</a></li><li><a href="global.html#SIGFIG_HASH_LENGTH">SIGFIG_HASH_LENGTH</a></li><li><a href="global.html#sizeOf">sizeOf</a></li><li><a href="global.html#sizeToBytes">sizeToBytes</a></li><li><a href="global.html#sum">sum</a></li><li><a href="global.html#testDigitcase">testDigitcase</a></li><li><a href="global.html#testLowercase">testLowercase</a></li><li><a href="global.html#testMinimumLength">testMinimumLength</a></li><li><a href="global.html#testSpecialcase">testSpecialcase</a></li><li><a href="global.html#testUppercase">testUppercase</a></li><li><a href="global.html#toFixed">toFixed</a></li><li><a href="global.html#toGeoJSON">toGeoJSON</a></li><li><a href="global.html#toPrecison">toPrecison</a></li><li><a href="global.html#wait">wait</a></li><li><a href="global.html#waitFor">waitFor</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Fri Feb 08 2019 13:03:16 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
